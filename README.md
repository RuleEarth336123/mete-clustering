**介绍**

*数据准备*

二维或三维的数值型数据。

*选择聚类数*

使用Davies–Bouldin Index (DBI) 和 I 指数来帮助选择聚类数。


**安装依赖**
pip install -r requirements.txt

**执行脚本**
python run.py

**显卡加速**
bash prallel/build.sh

=======
### **介绍**

### *数据准备* 

二维或三维的数值型数据。
### *选择聚类数*

使用Davies–Bouldin Index (DBI) 和 I 指数来帮助选择聚类数。

### *特征工程*
DTW
余弦距离

### *算法实现*
**kmeans**

根据多特征融合的K-Means轨迹聚类算法：
**1.动态距离规整**
    DTW的基本思想是找到一个最佳的匹配方式，使得两个时间序列的相似度最大或者不相似度最小。
    假设我们有两个时间序列
    $X = (x_1, x_2, ..., x_n)$，$Y = (y_1, y_2, ..., y_m)$，
    其中$x_i, y_j \in \mathbb{R}^d$是$d$维的向量。我们定义一个$n \times m$的矩阵$D$，其中$D(i, j)$表示$x_i$和$y_j$之间的欧氏距离，即$D(i, j) = ||x_i - y_j||^2$。

我们定义一个扭曲路径$P = (p_1, p_2, ..., p_k)$，其中$p_l = (i, j)$表示$X$的第$i$个元素和$Y$的第$j$个元素之间的匹配。我们希望找到一个使得路径上所有匹配对的欧氏距离之和最小的扭曲路径，即
$$
P^* = \arg\min_{P} \sum_{l=1}^{k} D(p_l)
$$
这个问题可以通过动态规划来解决。我们定义一个累积距离矩阵$C$，其中$C(i, j)$表示从$(1, 1)$到$(i, j)$的最小扭曲路径的距离。$C(i, j)$可以通过以下方式计算：
$$
C(i, j) = D(i, j) + \min\{C(i-1, j), C(i, j-1), C(i-1, j-1)\}
$$
最后，$(n, m)$处的$C$值就是两个时间序列的DTW距离。

**2.余弦相似度**
余弦相似度是一种衡量两个向量方向相似度的度量，它的值范围是-1到1。如果两个向量的方向完全相同，那么它们的余弦相似度就是1；如果它们的方向完全相反，那么它们的余弦相似度就是-1。
Cosine Similarity = $\frac{A \cdot B}{||A||_2 \times ||B||_2}$


*模型评估*
使用内部评估指标，如DBI、CH指数和轮廓系数（SC），来评估聚类结果的质量。基于密度
层次聚类

### *模型评估*
使用内部评估指标，如DBI、CH指数和轮廓系数（SC），来评估聚类结果的质量。

### **安装依赖**
pip install -r pkglist.txt

### **执行脚本**
python run.py
